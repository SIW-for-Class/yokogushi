# architecture.md
## Yokogushi（ナレッジスペース）アーキテクチャ概要

本ドキュメントは、`spec.md` で定義した共通仕様を **どの実装（variant）でも観察できる形**で説明するための、概念レベルの設計メモである。  
ここでの「正しさ」は目的ではなく、**観察の手がかり**を提供することを目的とする。

---

## 1. 全体像（レイヤー）

Yokogushi は、最小限の Web アプリとして次のレイヤーで構成される。

- **Presentation（表示）**：HTML / CSS（+必要なら JS）
- **Application（処理）**：ルーティング、バリデーション、状態遷移
- **Data（永続化）**：SQLite（またはファイル）への保存・取得
- **Runtime（実行環境）**：Linux上のプロセス、ポート、ログ

どの言語でも最終的には、  
**HTTPリクエスト → 処理 → DB → HTTPレスポンス**  
の流れに集約される。

---

## 2. データの流れ（基本シナリオ）

### 2.1 エントリ作成（Create）
1. ブラウザが `GET /entries/new` を送る  
2. サーバが HTML フォームを返す  
3. ユーザが入力して `POST /entries`  
4. サーバが入力を検証（title/body 必須）  
5. DBへ `INSERT`（statusは `open`）  
6. `302 Redirect` で詳細または一覧へ誘導（実装により異なる）

観察ポイント：
- POSTのbodyがどこで読まれるか
- INSERTがどこで発生するか
- リダイレクトの意味（画面更新と二重送信防止）

---

### 2.2 一覧表示（List）
1. ブラウザが `GET /` または `GET /entries`
2. サーバが DBへ `SELECT`（新しい順など）
3. HTMLとして一覧を返す

観察ポイント：
- 一覧の並び順はどこで決まるか
- DBアクセスとテンプレ生成の責務分離

---

### 2.3 詳細表示（Detail）
1. ブラウザが `GET /entries/{id}`
2. サーバが DBへ `SELECT ... WHERE id=?`
3. HTMLとして詳細を返す

観察ポイント：
- `{id}` のパスパラメータをどこで抽出するか
- 存在しない id の扱い（404/エラー画面）

---

### 2.4 ステータス切替（open/closed）
1. 詳細画面から `POST /entries/{id}/status`
2. サーバが `UPDATE entries SET status=?, updated_at=?`
3. 詳細へ `302 Redirect`（または JSON 応答）

観察ポイント：
- 「状態遷移」がどこに書かれているか（toggle/明示指定）
- DB更新とUI表示の関係

---

## 3. コンポーネント（概念）

実装によりファイル構成は異なるが、概念としては以下を分けると観察しやすい。

- **Router**：URLと処理（handler）を結びつける
- **Handler / Controller**：入力を受け取り、DBを呼び、出力を決める
- **DB Access**：SQLの実行、接続管理、行の変換
- **View / Template**：HTMLを組み立てる（SSR）
- **Static**：CSS/JS/画像の配信（最小でよい）

---

## 4. 代表的なファイル配置（例）

### 4.1 PurePython（http.server等）の例（概念）
- `server.py`：HTTP受信、ルーティング、レスポンス生成
- `db.py`：SQLite操作（INSERT/SELECT/UPDATE）
- `templates/`：HTMLテンプレ（文字列でも可）
- `static/`：CSS/JS

### 4.2 フレームワーク（Flask等）の例（概念）
- `app.py`：ルート定義、設定、起動
- `routes.py`：handler（エンドポイント）
- `db.py`：DB操作
- `templates/`：Jinja等
- `static/`：CSS/JS

※ 重要なのは「どのファイルに何があるか」ではなく、  
**HTTP → 処理 → DB → 表示**の責務がどこに置かれているかである。

---

## 5. 実行・運用の観察（Linux）

### 5.1 プロセス
- サーバは1つ以上のプロセスとして動作する
- PID、実行ユーザ、起動コマンドを観察できる

例：
- `ps aux | grep <server>`
- `ss -lntp | grep :<port>`（待受ポート）

### 5.2 ログ
- 学習用のため、まずは標準出力へのログでよい
- 可能なら「リクエスト行」「ステータスコード」「処理時間」を出す

例（概念）：
- `[REQ] GET /entries 200 12ms`
- `[REQ] POST /entries 302 5ms`

---

## 6. 失敗（エラー）の設計

教材として、失敗を隠さない。

- 入力不足（title/bodyなし）
  - 400にする/同画面にエラー表示（どちらでも可）
- 存在しないID
  - 404（推奨）
- DBエラー
  - 例外を握りつぶさず、ログとともに観察可能にする

---

## 7. 拡張の方向（extensions向け）

`variants/extensions` では、次のような拡張で比較ができる。

- JSON API追加（SSRとの比較）
- 検索（LIKE / インデックス）
- タグ
- ログの整備（アクセスログ形式）
- 永続化の差し替え（SQLite → PostgreSQL等）
- 実行方式の差（単一バイナリ/プロセスマネージャ/コンテナ等）

拡張は目的ではなく、**観察テーマを増やすための手段**として扱う。

---

## 8. まとめ（観察の軸）

このプロジェクトで観察したい軸は次の3つである。

1. **責務の分離**：HTTP処理／業務処理／DB／表示がどこにあるか  
2. **データの流れ**：入力→保存→取得→表示の往復  
3. **実行環境**：プロセス・ポート・ログとして現れる挙動

言語やフレームワークが変わっても、  
この3点が追える設計になっていれば、横串（Yokogushi）は刺さる。
